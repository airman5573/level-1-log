# Level-1 로그

## 클린 코드
- var를 쓰지 말고 let, const만 사용한다
- forEach, map, reduce, filter, some, every, find, findIndex를 활용한다
- 함수의 줄수를 가급적 15줄 넘지 않도록 한다
- 식별자의 이름만 봐도 어떤 일을 하는지 짐작할 수 있도록 이름을 짓는다
- 코드가 너무 길지 않다면 constructor안에서 event를 걸고 element를 바인딩 해도 된다.
- return false, return true대신 그 식 자체를 return하는게 깔끔하다
- 가능하다면 if - else대신 if문 안에서 return시켜 버린다
- 3항 연산자를 활용한다
- ?? 연산자를 활용한다
- && 연산자로 if문을 대체할 수 있다

## Execution Context & Scope
### Execution Context
(문법적 오류가 없다는 전제 하에) 함수가 호출되었을때 우리가 작성한 js코드는 실행하기 전에 먼저 평가 과정을 거칩니다.  
이때 Execution Context 즉 테이블이 하나 생성되고 JS엔진은 식별자들을 읽어가면서 이 테이블에 기록을 합니다.  
그리고 실행 단계가 되었을때 코드에 어떤 식별자를 만나면 Execution Context에서 찾아 돌려주거나 아니면 새로 할당합니다.

### Scope
스코프는 어떤 변수가 유효한 범위를 의미합니다. 여기서 유효하다는것은 JS Engine이 실행 컨택스트에서 해당 변수를 찾을 수 있다는 것이고, 반대로 유효하지 않다는 것은 실행 컨택스트에서 찾지 못한다는 것입니다.

### Scope Chain
함수(outer) 안에 함수(inner)가 정의되어 있는 경우, 두 함수의 실행 컨택스트는 연결됩니다. 그래서 JS Engine은 inner함수의 실행 컨택스트에서 원하는 식별자를 못찾는 경우, 연결되어 있는 상위 컨택스트로 넘어가서 찾습니다. 이것이 스코프 체인입니다.

### 질문
- 그렇다면 다른 언어들은, 예를들어 C언어는 이런 실행 컨택스트나 스코프 체인이 없는가?
- Node.js도 동일하게 작동 하는가?

## Event Loop
브라우저는 일반적으로 우리가 작성한 JS코드를 여러 쓰레드에서 동시에 실행하지 않습니다.  
이렇게 되면 컴퓨터 자원을 최대한으로 활용해서 JS코드를 더 빠르게 실행시키겠지만,  
동시성 문제와 경쟁상태가 생길 위험이 있습니다. 그래서 브라우저는 적어도 우리가 작성한 코드는 단일 쓰레드에서 작동하도록 설계되었습니다.  
또한 사용자의 입력을 비롯한 다양한 이벤트들을 우선순위에 맞게 놓치지 않고 처리하기 위해 queue와 event loop를 도입했습니다.  
즉 할일을 쌓아놓고 하나씩 빼서 처리해 주는 방식을 채택한겁니다.

### 질문
- iOS와 Android는 어떤 방식으로 이벤트를 처리할까? 이것도 단일 쓰레드방식을 사용하고, event loop가 있을까?

## setTimeout, setInterval, requestAnimationFrame
### setTimeout
setTimeout은 지정한 시간후에 콜백함수를 호출합니다.  
다만, 싱글 쓰레드이기 때문에 앞에 일이 많이 쌓여있을 수 있기에 시간을 보장하지 않습니다.  
그리고 0을 넣어도 바로 호출되지 않고, 4.7ms정도 후에 호출됩니다.

### setInterval
setInterval은 지정한 매 시간 간격으로 콜백 함수가 호출됩니다.  당연한 소리지만, 콜백함수를 처리하는데 2초가 걸리고 지정한 시간을 1초로 했다면, 매 2초마다 호출됩니다.  
이것도 해당 시간을 항상 보장하지는 못합니다.

### requestAnimationFrame
setTimeout으로 애니메이션을 구현한 때가 있었습니다.  
하지만 이 방법은 frame drop이 발생하기 쉽습니다.  
그래서 사용자 경험을 향상시키기 위해 requestAnimationFrame이 등장했습니다.  
이 함수에 넣은 콜백함수는 main thread가 render phase에 들어가기 전에 호출 됩니다.  
따라서, DOM조작이 이루어 진 후에 화면에 그려지는것이 보장되기 때문에 frame drop이 발생하지 않습니다.

### 질문
setTimeout을 재귀적으로 호출하는것과 setInterval을 사용하는것의 차이는?

## CSS : Layout, Box Model, Position, Flexbox
CSS도 JS만큼이나 많이 발전했습니다. 특히 프론트 개발자들을 골치아프게 했던 레이아웃을 잡는 일을 쉽게 만들어 주었습니다.  Flexbox와 Grid가 그 주역입니다.

## Jest
도메인 코드를 테스트 할때 사용합니다. UI도 테스트 가능한것 같긴 한데, 잘 모르겠습니다.

## Object
원시 타입과는 다른 타입의 데이터 타입입니다. key-value로 값을 지정할 수 있습니다.  그냥 다른 변수에 객체를 할당 한다면 주소값만 넘겨주는 것이기 때문에 주의해야 합니다.  

## Prototype
ES6에서 클래스가 나오긴 했지만, 기본적으로 JS는 클래스 언어가 가지고 있는 ‘상속’의 개념이 아닌 ‘공유’의 개념을 채택했습니다.   생성자 함수로 만든 인스턴스는 생성자 함수의 prototype 객체와 연결되어 있습니다.  
따라서, 해당 인스턴스가 직접 함수의 주소값을 가지고 있지 않아도 생성자 함수의 prototype에 있는 함수를 찾아서 사용할 수 있습니다.

## 함수 & 클로저
함수 안에 함수가 정의되어 있는 경우 두개의 실행 컨택스트가 만들어 지고, 이 둘은 연결되어 있습니다.  
그리고 브라우저에는 가비지 컬랙터라는 프로그램이 있습니다.  
이 프로그램은 메모리에 더이상 참조되지 않는 값이 있다면 그 녀석을 메모리에서 해제 시킵니다.  
덕분에 우리는 메모리의 해제에 대해 크게 관심을 가지지 않고 편하게 코딩을 할 수 있습니다.  
그런데 함수 안에 함수가 정의되어 있고 inner함수에서 outer함수의 변수를 참조하고 있는 상황에서 outer함수의 마지막줄까지 코드가 실행되고 inner함수를 리턴 한다고 합시다.  
이런 경우 outer함수의 실행 컨택스트는 콜스택에서 떨어져 나갔지만, inner함수에서 outer함수의 변수들을 참조하고 있기 때문에  
참조되고 있는 값들은 가비지 컬렉터가 메모리에서 해제하지 않습니다. 이런 현상이나 함수를 클로저라 부릅니다.

## Module & State Management
### Module
browser에서도 js파일을 module처럼 import할 수 있게 되었습니다.  
이렇게 분리가 되면 변수나 함수가 보호되기 때문에 더 안전하게 코딩할 수 있습니다.

### State Management
웹어플리케이션이 점점 복잡해 짐에 따라 상태를 관리하는 일도 어려워 졌습니다.  
여기서 ‘상태’는 사용자에게 어떤 뷰를 보여줘야하는지 판단하는 척도가 되며,  
동시에 그 뷰에 들어갈 데이터 자체를 의미합니다.  
level-1때 이 상태값을 리액트 같은 프레임워크 없이 관리하고 그에 따라 뷰를 보여주는건 저에게 도전적인 일이었습니다.

## Webpack & Module Bundler
웹팩은 모듈 번들러입니다. 적절한 로더만 있다면 다양한 형태의 파일들을 마치 js파일처럼 import할 수 있습니다.  
또한 이런 파일들의 의존성들을 알아서 관리해 주기 때문에 이제는 개발할때 필수로 사용하는 프로그램이 되었다고 생각합니다.  
다만 최근에는 webpack이 제공하는 기능의 90%이상을 커버하면서 속도는 몇배나 빠른 Vite가 등장했습니다.  
이 외에도 snowpack, parcel등 다양한 번들러 도구들이 나와있습니다.

## 웹의 동작
우리가 로컬에서 작성한 js 파일은 바로 하드디스크에서 RAM으로 올려서 실행됩니다.  하지만 실제 상용 서비스들은 전부 서버로부터 파일을 다운받아 실행합니다.  이때 어떤 과정을 거쳐 파일을 받아오고 화면에 그려주는지 알 필요성이 있습니다.  

## AJAX & JSON
### AJAX
서버로부터 data를 요청할때 사용자 경험을 위해서 비동기적으로 요청하는것이 좋습니다.  
이미 브라우저에 내장되어 있는 fetch나 유명한 라이브러리인 axios를 사용하면 알아서 비동기적으로 데이터를 가져와 줍니다.

### JSON
서버로부터 받는 데이터에는 다양한 형식이 있습니다.  
JSON도 이것의 한 종류입니다. 서버는 클라이언트의 요청을 받아 JSON형식으로 데이터를 보내주고,  
또 받는 쪽에서는 JSON형식으로 해당 데이터를 해석해 자신의 언어에 맞는 데이터로 변환해 사용합니다.  
이것은 비단 브라우저쪽에서만 이렇게 하는게 아니라 iOS/Android앱 등 다양한 플랫폼에서 JSON 분석기를 만들어서 활용하고 있습니다.

## RESTful API
POST, GET, PUT, DELETE등 이미 만들어진 http method를 잘 활용해 그 메소드의 의도에 맞게끔 디자인한 API를 의미합니다.

## Promise & async/await
### Promise
기본적으로 Promise를 활용하면 콜백의 depth가 낮아져서 가독성이 좋아집니다.  
그리고 Promise의 내장 함수인 all, race, allSettled를 활용하면 여러개의 비동기 작업들을 효율적으로 관리할 수 있습니다. 

### async/await
Promise를 반환하는 함수를 호출할때 await키워드를 쓰면 then을 쓰지 않아도 마치 동기적으로 작동하듯 결과값을 리턴합니다.  
then으로 그 비동기 작업 결과를 처리하는것 보다 코드 길이가 짧고 가독성이 좋아집니다.

## debounce, throttle
스크롤혹은 input에 사용자가 값을 입력하는 경우 이벤트들이 많이 들어옵니다.  
이때 해당 이벤트에 일일이 반응해야될 필요가 없는 경우에는 debounce와 throttle 기법을 사용할 수 있습니다.  debounce는 맨 마지막 이벤트만 받아서 처리하는것이고, throttle은 중간중간 쉬면서 이벤트를 처리하는것입니다.

## intersectionObserver
scroll이벤트가 발생할때 콜백 함수는 렌더링 페이즈에서 동기적으로 호출됩니다.  
다시말해서 window에 스크롤 이벤트를 걸어놓고 콜백함수를 호출하게 만들면 사용자 경험에 안좋은 영향을 끼칠 수 있습니다.  scroll이벤트는 매우 빠르게 아주 많이 호출되기 때문입니다. 만약에 우리가 단순히 관찰 대상(엘리먼트)와 뷰포트(혹은 다른 엘리먼트)의 교차하는 정도를 관찰하고자 한다면 intersectionObserver가 더 효율적입니다. 이유는 잘 모르겠습니다.

## Typescript
javascript에 타입을 더한 언어입니다. 함수에 들어오고 나가는 값들에 타입을 지정할 수 있습니다.  
class, abstract, interface, enum 등등 설계할때 유용한 도구들을 제공합니다.  
가장 좋은점은 내 코드가 어떻게 동작할지 더 잘 유추할 수 있어 유지보수에 좋다는 것이며,  
두번째로는 VSC에서 함수의 인자값에 어떤 데이터 타입의 값이 들어가야 하는지 알려줘서 개발이 편해진다는 것입니다.  
아직까지는 Typescript로 작성한 코드는 js로 변환되어야만 브라우저에서 실행될 수 있습니다.  하지만 미래에는 브라우저에서 바로 ts를 읽고 실행할 수도 있을것 같습니다.  
typescript로 작성된 라이브러리를 사용할때, 타입 에러가 발생하면 머리가 아픕니다.  generic안에 또 generic이 있거나, 알수없는 용어들과 커스텀 타입이 등장하면 문제 원인 분석할 힘이 안납니다.  

## Cypress
내 코드를 브라우저에 올리고 마치 사람이 클릭하는것처럼 클릭도 하고 스크롤도 하는등 UI테스트를 해줍니다.  
- intercept를 통해 api호출을 가로챌수도 있습니다.  
- 테스트 사이사이에 localStorage의 값을 보존하지 않기 때문에 따로 처리를 해줘야 합니다.
- support폴더 안에 커스텀 커맨드를 만들어 반복되는 작업들을 줄일 수 있습니다.
- 테스트 코드가 실행되기전, 각 테스트가 실행되기 전, 후 어떤일을 할지 지정할 수 있습니다.
- visible을 주의해야 합니다. display: none이 아니더라도 뷰포트 밖에 있으면 안보이는걸로 판단합니다.
- 내부적으로 jQuery를 사용하기 때문에 css selector로 엘리먼트를 찝을 수 있습니다.
- cypress함수는 비동기적으로 작동합니다. 한번 사악 실행하고 그 순서에 맞게 하나하나 실행합니다. 그래서 jQuery쓰듯이 값을 할당하려고 하면 의도한대로 작동하지 않습니다.
- invoke로 element의 attribute나 text를 가져올 수 있습니다.
- alert, confirm도 사용 가능하고 클릭도 됩니다.
- should ~ 도 사용할 수 있고, expect도 사용할 수 있습니다. 차이점은 should는 실패해도 몇번 더 도전해 본다는 것이며, expect는 실패하면 거기서 끝입니다.
- then으로 연결하면 안에서는 동기적으로 jQuery를 쓸 수 있습니다.
